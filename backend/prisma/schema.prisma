// FlowPay Database Schema
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  CREATOR
  BRAND
  ADMIN
}

enum KycStatus {
  PENDING
  APPROVED
  REJECTED
  REQUIRED
  DELETED
}

enum DealState {
  DRAFT
  FUNDED
  RELEASED
  DISPUTED
  REFUNDED
}

enum MilestoneState {
  PENDING
  SUBMITTED
  APPROVED
  RELEASED
  DISPUTED
}

enum DisputeStatus {
  OPEN
  ESCALATED
  UNDER_REVIEW
  RESOLVED
  WITHDRAWN
}

enum DisputeCategory {
  QUALITY
  DEADLINE
  COMMUNICATION
  PAYMENT
  SCOPE
  OTHER
}

enum ResolutionType {
  FULL_REFUND
  PARTIAL_REFUND
  FAVOR_CREATOR
  FAVOR_BRAND
  COMPROMISE
  DISMISS
}

enum PaymentProvider {
  STRIPE
  MANGOPAY
  CRYPTO
}

enum PayoutStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELED
}

enum InvoiceStatus {
  GENERATED
  SENT
  PAID
  OVERDUE
  CANCELLED
}

model User {
  id                      String    @id @default(cuid())
  email                   String    @unique
  hashedPassword          String?   @map("hashed_password")
  role                    UserRole
  country                 String?
  stripeAccountId         String?   @map("stripe_account_id")
  kycStatus               KycStatus @default(PENDING) @map("kyc_status")
  suspended               Boolean   @default(false)
  suspendedAt             DateTime? @map("suspended_at")
  notificationPreferences Json?     @map("notification_preferences")
  deletedAt               DateTime? @map("deleted_at")
  createdAt               DateTime  @default(now()) @map("created_at")
  updatedAt               DateTime  @updatedAt @map("updated_at")

  // Relationships
  brandProjects     Project[]           @relation("BrandProjects")
  creatorDeals      Deal[]              @relation("CreatorDeals")
  raisedDisputes    Dispute[]           @relation("DisputeRaiser")
  disputeResponses  DisputeResponse[]   @relation("DisputeResponses")
  disputeResolutions DisputeResolution[] @relation("DisputeResolutions")
  events            Event[]             @relation("UserEvents")
  refreshTokens     RefreshToken[]      @relation("UserRefreshTokens")

  @@map("users")
  @@index([email])
  @@index([kycStatus])
  @@index([deletedAt])
}

model Project {
  id          String   @id @default(cuid())
  brandId     String   @map("brand_id")
  title       String
  description String?
  status      String   @default("active")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relationships
  brand       User     @relation("BrandProjects", fields: [brandId], references: [id], onDelete: Cascade)
  deals       Deal[]

  @@map("projects")
}

model Deal {
  id           String    @id @default(cuid())
  projectId    String    @map("project_id")
  creatorId    String    @map("creator_id")
  currency     String    @default("usd")
  amountTotal  Int       @map("amount_total") // Amount in cents
  escrowId     String?   @map("escrow_id") // Provider-specific escrow ID
  state        DealState @default(DRAFT)
  acceptedAt   DateTime? @map("accepted_at")
  fundedAt     DateTime? @map("funded_at")
  completedAt  DateTime? @map("completed_at")
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")

  // Relationships
  project      Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  creator      User         @relation("CreatorDeals", fields: [creatorId], references: [id])
  milestones   Milestone[]
  contract     Contract?
  disputes     Dispute[]
  payouts      Payout[]
  invoices     Invoice[]
  events       Event[]

  @@map("deals")
}

model Milestone {
  id          String         @id @default(cuid())
  dealId      String
  title       String
  description String?
  amount      Int            // Amount in cents
  dueAt       DateTime?
  state       MilestoneState @default(PENDING)
  submittedAt DateTime?
  approvedAt  DateTime?
  releasedAt  DateTime?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  // Relationships
  deal         Deal           @relation(fields: [dealId], references: [id], onDelete: Cascade)
  deliverables Deliverable[]
  payouts      Payout[]
  invoices     Invoice[]

  @@map("milestones")
}

model Deliverable {
  id           String    @id @default(cuid())
  milestoneId  String
  url          String?   // Link to deliverable (social post, etc.)
  fileUrl      String?   // S3 URL for uploaded files
  fileHash     String?   // SHA-256 hash for integrity
  fileName     String?
  fileSize     Int?      // Size in bytes
  submittedAt  DateTime  @default(now())
  checks       Json?     // Validation results
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Relationships
  milestone    Milestone @relation(fields: [milestoneId], references: [id], onDelete: Cascade)

  @@map("deliverables")
}

model Contract {
  id                String    @id @default(cuid())
  dealId            String    @unique
  version           String    @default("1.0")
  pdfUrl            String?
  signatureBrand    String?   // Brand signature data
  signatureCreator  String?   // Creator signature data
  signedAt          DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relationships
  deal              Deal      @relation(fields: [dealId], references: [id], onDelete: Cascade)

  @@map("contracts")
}

model Dispute {
  id                    String          @id @default(cuid())
  dealId                String
  raisedByUserId        String
  reason                String
  category              DisputeCategory
  evidence              Json?           // Array of evidence objects
  requestedResolution   String          // What resolution the disputer wants
  requestedAmount       Int?            // Requested refund amount in cents
  status                DisputeStatus   @default(OPEN)
  priority              String?         // LOW, MEDIUM, HIGH, URGENT
  escalatedAt           DateTime?
  escalatedBy           String?
  resolvedAt            DateTime?
  resolvedBy            String?
  adminNotes            String?
  resolutionTimeHours   Int?            // Auto-calculated field
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt

  // Relationships
  deal          Deal                  @relation(fields: [dealId], references: [id], onDelete: Cascade)
  raisedBy      User                  @relation("DisputeRaiser", fields: [raisedByUserId], references: [id])
  responses     DisputeResponse[]
  resolutions   DisputeResolution[]

  @@map("disputes")
}

model DisputeResponse {
  id              String   @id @default(cuid())
  disputeId       String
  userId          String
  message         String
  evidence        Json?    // Array of evidence objects
  isAdminResponse Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relationships
  dispute         Dispute  @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  user            User     @relation("DisputeResponses", fields: [userId], references: [id])

  @@map("dispute_responses")
}

model DisputeResolution {
  id             String         @id @default(cuid())
  disputeId      String
  resolvedBy     String
  resolutionType ResolutionType
  resolution     String         // Detailed resolution explanation
  refundAmount   Int?           // Refund amount in cents if applicable
  newDeadline    DateTime?      // New milestone deadline if applicable
  actionRequired Json?          // Required actions from parties
  createdAt      DateTime       @default(now())

  // Relationships
  dispute        Dispute        @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  resolvedByUser User           @relation("DisputeResolutions", fields: [resolvedBy], references: [id])

  @@map("dispute_resolutions")
}

model Invoice {
  id            String        @id @default(cuid())
  dealId        String
  milestoneId   String?
  invoiceNumber String        @unique
  amount        Int           // Total amount in cents including tax
  currency      String        @default("usd")
  taxAmount     Int           @default(0) // Tax amount in cents
  taxType       String?       // VAT, GST, NONE
  issueDate     DateTime
  dueDate       DateTime?
  status        InvoiceStatus @default(GENERATED)
  pdfUrl        String?       // URL to generated PDF
  sentAt        DateTime?
  paidAt        DateTime?
  metadata      Json?         // Additional invoice data (tax rates, addresses, etc.)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  // Relationships
  deal          Deal          @relation(fields: [dealId], references: [id], onDelete: Cascade)
  milestone     Milestone?    @relation(fields: [milestoneId], references: [id])

  @@map("invoices")
  @@index([dealId])
  @@index([status])
  @@index([issueDate])
}

model Payout {
  id           String          @id @default(cuid())
  dealId       String
  milestoneId  String?
  provider     PaymentProvider
  providerRef  String          // Provider-specific transaction ID
  amount       Int             // Amount in cents
  currency     String          @default("usd")
  status       PayoutStatus    @default(PENDING)
  metadata     Json?           // Provider-specific data
  processedAt  DateTime?
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  // Relationships
  deal         Deal            @relation(fields: [dealId], references: [id], onDelete: Cascade)
  milestone    Milestone?      @relation(fields: [milestoneId], references: [id])

  @@map("payouts")
}

model Event {
  id          String   @id @default(cuid())
  actorUserId String?
  dealId      String?
  type        String   // e.g., "deal.created", "milestone.approved"
  payload     Json     // Event data
  createdAt   DateTime @default(now())

  // Relationships
  actor       User?    @relation("UserEvents", fields: [actorUserId], references: [id])
  deal        Deal?    @relation(fields: [dealId], references: [id])

  @@map("events")
}

// Refresh token storage for JWT refresh functionality
model RefreshToken {
  id          String   @id @default(cuid())
  tokenHash   String   @unique @map("token_hash") // SHA-256 hash of the token
  userId      String   @map("user_id")
  email       String
  role        String
  deviceId    String?  @map("device_id") // Optional device identifier
  userAgent   String?  @map("user_agent") // Browser/app user agent
  ipAddress   String?  @map("ip_address") // IP address when token was created
  expiresAt   DateTime @map("expires_at")
  createdAt   DateTime @default(now()) @map("created_at")
  lastUsed    DateTime @default(now()) @map("last_used")

  // Relationships
  user        User     @relation("UserRefreshTokens", fields: [userId], references: [id], onDelete: Cascade)

  @@map("refresh_tokens")
  @@index([userId])
  @@index([expiresAt])
  @@index([tokenHash])
}

// Global indexes removed - they should be defined within model blocks